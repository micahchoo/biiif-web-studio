import { IIIFManifest, IIIFCollection, IIIFCanvas, IIIFAnnotation, IIIFItem, IngestResult } from '../types';
import { load as parseYaml } from 'js-yaml';

// --- Helpers ---

const readFileAsText = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsText(file);
  });
};

const getImageDimensions = (file: File): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
    };
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
};

const generateLabel = (filename: string): string => {
  let name = filename.replace(/\.[^/.]+$/, ""); // Remove ext
  name = name.replace(/^\d+_/, ""); // Remove sorting numbers
  name = name.replace(/[_-]/g, " "); // Replace separators
  return name.replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase()))); // Capitalize
};

export const createManifest = (name: string, id: string): IIIFManifest => {
  return {
    context: "http://iiif.io/api/presentation/3/context.json",
    id: id,
    type: "Manifest",
    label: { en: [name] },
    items: [],
    summary: { en: ["Generated by Biiif Web Studio"] }
  };
};

// --- Tree Building ---

interface FileTree {
  name: string;
  path: string;
  files: Map<string, File>;
  directories: Map<string, FileTree>;
}

const buildTree = (files: File[]): FileTree => {
  const root: FileTree = { name: 'root', path: '', files: new Map(), directories: new Map() };
  
  for (const file of files) {
    const parts = file.webkitRelativePath.split('/');
    let current = root;
    
    // If just a file with no path (e.g. simple drag drop), handle gracefully
    if (parts.length <= 1) {
        current.files.set(file.name, file);
        continue;
    }

    // Navigate/Build path
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current.directories.has(part)) {
        current.directories.set(part, { 
          name: part, 
          path: current.path ? `${current.path}/${part}` : part,
          files: new Map(), 
          directories: new Map() 
        });
      }
      current = current.directories.get(part)!;
    }
    
    current.files.set(parts[parts.length - 1], file);
  }
  return root;
};

// --- Processing ---

const applyMetadata = async (resource: IIIFItem, tree: FileTree) => {
    // Check info.yml, collection.yml, manifest.json
    const metaFile = tree.files.get('info.yml') || tree.files.get('collection.yml') || tree.files.get('manifest.json');
    if (metaFile) {
        try {
            const text = await readFileAsText(metaFile);
            const data = metaFile.name.endsWith('json') ? JSON.parse(text) : parseYaml(text) as any;
            if (data.label) resource.label = { en: [data.label] };
            if (data.summary || data.description) resource.summary = { en: [data.summary || data.description] };
            if (data.rights) resource.rights = data.rights;
        } catch (e) {
            console.warn(`Error parsing metadata for ${tree.name}`, e);
        }
    }

    // Check thumbnail
    const thumbFile = tree.files.get('thumb.jpg') || tree.files.get('thumb.png') || tree.files.get('thumbnail.jpg');
    if (thumbFile) {
        resource.thumbnail = [{
            id: URL.createObjectURL(thumbFile),
            type: 'Image',
            format: thumbFile.type
        }];
    }
};

const buildManifest = async (tree: FileTree, baseUrl: string): Promise<IIIFManifest> => {
    const manifestId = `${baseUrl}/${tree.name === 'root' ? 'manifest' : tree.name}`;
    const name = generateLabel(tree.name === 'root' ? 'New Manifest' : tree.name);
    
    const manifest: IIIFManifest = {
        context: "http://iiif.io/api/presentation/3/context.json",
        id: manifestId,
        type: "Manifest",
        label: { en: [name] },
        items: []
    };

    await applyMetadata(manifest, tree);

    const images = Array.from(tree.files.entries())
        .filter(([name, file]) => file.type.startsWith('image/'))
        .filter(([name]) => !name.includes('thumb'));

    // Natural sort
    images.sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true, sensitivity: 'base' }));

    const canvases: IIIFCanvas[] = [];
    for (let i = 0; i < images.length; i++) {
        const [filename, file] = images[i];
        const dimensions = await getImageDimensions(file);
        const canvasId = `${manifestId}/canvas/${i + 1}`;
        const url = URL.createObjectURL(file);

        const canvas: IIIFCanvas = {
            id: canvasId,
            type: "Canvas",
            label: { none: [generateLabel(filename)] },
            height: dimensions.height,
            width: dimensions.width,
            items: [{
                id: `${canvasId}/page/paint`,
                type: "AnnotationPage",
                items: [{
                    id: `${canvasId}/annotation/paint`,
                    type: "Annotation",
                    motivation: "painting",
                    body: { id: url, type: "Image", format: file.type },
                    target: canvasId
                }]
            }],
            annotations: [],
            _blobUrl: url
        };

        // Canvas Metadata
        const baseName = filename.substring(0, filename.lastIndexOf('.'));
        const sidecarMeta = tree.files.get(`${baseName}.yml`) || tree.files.get(`${baseName}.json`);
        if (sidecarMeta) {
             try {
                const text = await readFileAsText(sidecarMeta);
                const data = sidecarMeta.name.endsWith('json') ? JSON.parse(text) : parseYaml(text) as any;
                if (data.label) canvas.label = { en: [data.label] };
                if (data.description) canvas.summary = { en: [data.description] };
             } catch (e) {}
        }

        // Transcription
        const sidecarTxt = tree.files.get(`${baseName}.txt`);
        if (sidecarTxt) {
            const text = await readFileAsText(sidecarTxt);
            if (text.trim()) {
                canvas.annotations = [{
                    id: `${canvasId}/page/annotations`,
                    type: "AnnotationPage",
                    items: [{
                        id: `${canvasId}/annotation/transcription`,
                        type: "Annotation",
                        motivation: "supplementing",
                        body: { type: "TextualBody", value: text, format: "text/plain", language: "en" },
                        target: canvasId
                    }]
                }];
            }
        }
        canvases.push(canvas);
    }
    manifest.items = canvases;
    return manifest;
};

const processNode = async (tree: FileTree, baseUrl: string): Promise<IIIFItem | null> => {
    const images = Array.from(tree.files.entries())
        .filter(([name, file]) => file.type.startsWith('image/'))
        .filter(([name]) => !name.includes('thumb'));

    // Biiif Logic: 
    // If has images -> Manifest (ignore subdirs for structure, though biiif strictly creates manifest from folder with images)
    // If no images but has dirs -> Collection

    if (images.length > 0) {
        return await buildManifest(tree, baseUrl);
    }

    if (tree.directories.size > 0) {
        const collectionId = `${baseUrl}/${tree.name === 'root' ? 'collection' : tree.name}`;
        const name = generateLabel(tree.name === 'root' ? 'New Collection' : tree.name);
        
        const collection: IIIFCollection = {
            context: "http://iiif.io/api/presentation/3/context.json",
            id: collectionId,
            type: "Collection",
            label: { en: [name] },
            items: []
        };

        await applyMetadata(collection, tree);

        const sortedDirs = Array.from(tree.directories.values())
            .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

        for (const dir of sortedDirs) {
            const item = await processNode(dir, collectionId);
            if (item) {
                collection.items.push(item);
            }
        }
        
        // If collection ends up empty (e.g. subdirs were empty), might return null or empty coll. 
        // Returning empty collection is fine.
        return collection;
    }

    return null;
};

export const processInput = async (files: FileList): Promise<IngestResult> => {
  const fileArray = Array.from(files);
  const tree = buildTree(fileArray);
  const baseUrl = `https://example.org/iiif/${Date.now()}`;
  
  const root = await processNode(tree, baseUrl);
  return { root };
};

export const exportManifest = (resource: IIIFItem) => {
  const cleanResource = JSON.parse(JSON.stringify(resource, (key, value) => {
    if (key === '_blobUrl') return undefined;
    return value;
  }));
  
  const blob = new Blob([JSON.stringify(cleanResource, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${resource.type.toLowerCase()}.json`;
  a.click();
  URL.revokeObjectURL(url);
};