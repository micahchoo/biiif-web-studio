<?xml version="1.0" encoding="UTF-8"?>
<custom_rules>
  <rule id="type-guard-1">
    <title>Type Guard Import Pattern</title>
    <description>Always import type guards from types.ts alongside IIIF types.</description>
    <pattern>
      <good>import { IIIFItem, isCanvas, isManifest, isCollection, isRange } from '../types';</good>
      <good>import { IIIFItem, getIIIFValue, isCanvas } from '../types';</good>
    </pattern>
    <available_guards>
      <guard name="isCanvas">Checks if item is IIIFCanvas (has width, height)</guard>
      <guard name="isManifest">Checks if item is IIIFManifest (has items array of canvases)</guard>
      <guard name="isCollection">Checks if item is IIIFCollection (has items array of manifests/collections)</guard>
      <guard name="isRange">Checks if item is IIIFRange (has members for table of contents)</guard>
      <guard name="isAnnotation">Checks if item is IIIFAnnotation</guard>
      <guard name="isAnnotationPage">Checks if item is IIIFAnnotationPage</guard>
      <guard name="isTextualBody">Checks if body is TextualBody (for annotations)</guard>
      <guard name="isExternalWebResource">Checks if body is ExternalWebResource</guard>
      <guard name="isSpecificResource">Checks if target is SpecificResource</guard>
    </available_guards>
  </rule>

  <rule id="type-guard-2">
    <title>Conditional Type Narrowing</title>
    <description>Use type guards in conditionals for automatic TypeScript narrowing.</description>
    <pattern>
      <code>function processItem(item: IIIFItem) {
  if (isCanvas(item)) {
    // TypeScript knows item is IIIFCanvas here
    return item.width * item.height;  // width/height are available
  }
  if (isManifest(item)) {
    // TypeScript knows item is IIIFManifest here
    return item.items.length;  // items is Canvas[]
  }
  if (isCollection(item)) {
    // TypeScript knows item is IIIFCollection here
    return item.items.length;  // items is (Manifest | Collection)[]
  }
}</code>
    </pattern>
    <note>Type guards provide TypeScript type narrowing - the compiler knows the specific type inside the if block</note>
  </rule>

  <rule id="type-guard-3">
    <title>Array Filtering with Type Guards</title>
    <description>Use type guards with array filter for typed results.</description>
    <pattern>
      <bad>const canvases = items.filter(i => i.type === 'Canvas') as IIIFCanvas[];</bad>
      <good>const canvases = items.filter(isCanvas);  // TypeScript knows this is IIIFCanvas[]</good>
    </pattern>
    <pattern>
      <code>// Get all canvases from a mixed array
const allCanvases = items.filter(isCanvas);

// Get all manifests
const allManifests = items.filter(isManifest);

// Get all collections
const allCollections = items.filter(isCollection);</code>
    </pattern>
  </rule>

  <rule id="type-guard-4">
    <title>Type-Based Conditional Rendering</title>
    <description>Use type guards for conditional rendering based on IIIF resource type.</description>
    <pattern>
      <bad>{item.type === 'Collection' ? '<FolderIcon />' : item.type === 'Manifest' ? '<BookIcon />' : '<ImageIcon />'}</bad>
      <good>{isCollection(item) ? '<FolderIcon />' : isManifest(item) ? '<BookIcon />' : '<ImageIcon />'}</good>
    </pattern>
    <pattern>
      <code>const TypeBadge: React.FC<{ item: IIIFItem }> = ({ item }) => {
  if (isCanvas(item)) {
    return <Badge color="blue" icon="image">Canvas</Badge>;
  }
  if (isManifest(item)) {
    return <Badge color="green" icon="menu_book">Manifest</Badge>;
  }
  if (isCollection(item)) {
    return <Badge color="amber" icon="folder">Collection</Badge>;
  }
  return <Badge>Unknown</Badge>;
};</code>
    </pattern>
  </rule>

  <rule id="type-guard-5">
    <title>Nested Type Checking</title>
    <description>Use type guards when traversing IIIF hierarchies.</description>
    <pattern>
      <code>const traverse = (item: IIIFItem) => {
  // Check type at each level
  if (isCollection(item) || isManifest(item)) {
    item.items?.forEach(child => traverse(child));
  }
  
  if (isCanvas(item)) {
    // Process canvas-specific data
    const annotations = item.items; // AnnotationPage[]
  }
  
  if (isRange(item)) {
    // Process range-specific data
    const members = item.members;
  }
};</code>
    </pattern>
  </rule>

  <rule id="type-guard-6">
    <title>Type Guards with Path Objects</title>
    <description>When working with path arrays or breadcrumb trails, use type guards with type assertions.</description>
    <pattern>
      <code>// Path items might have minimal type info
interface PathItem {
  id: string;
  label: string;
  type: string;
}

// Use type assertion + type guard
{path.map(p => (
  <Icon name={isCollection(p as any) ? 'folder' : isManifest(p as any) ? 'menu_book' : 'crop_original'} />
))}</code>
    </pattern>
    <note>When objects have partial type information, use `as any` with type guards for safe checking</note>
  </rule>

  <rule id="type-guard-7">
    <title>Type Guards with Service Results</title>
    <description>Use type guards when processing service operation results.</description>
    <pattern>
      <code>import { validateAndHeal } from '../services/validationHealer';

const { healed, issues } = validateAndHeal(item);

// Check if healing resulted in a specific type
if (isCanvas(healed)) {
  // Handle healed canvas
} else if (isManifest(healed)) {
  // Handle healed manifest
}</code>
    </pattern>
  </rule>

  <rule id="type-guard-8">
    <title>Avoid Common Anti-Patterns</title>
    <description>Never use these patterns - always use type guards instead.</description>
    <anti_patterns>
      <pattern>
        <bad>if (item.type === 'Canvas') { ... }</bad>
        <why>No TypeScript narrowing, prone to typos, doesn't handle edge cases</why>
      </pattern>
      <pattern>
        <bad>const isCanvas = item.type === 'Canvas';</bad>
        <why>Doesn't provide type narrowing, manual string comparison</why>
      </pattern>
      <pattern>
        <bad>switch (item.type) { case 'Canvas': ... }</bad>
        <why>Verbose, no type narrowing, hard to maintain</why>
      </pattern>
      <pattern>
        <bad>(item as any).type === 'Canvas'</bad>
        <why>Use isCanvas(item as any) instead for type-safe checking</why>
      </pattern>
    </anti_patterns>
  </rule>

  <rule id="type-guard-9">
    <title>Type Guards with find() and some()</title>
    <description>Use type guards with array methods that return single items.</description>
    <pattern>
      <code>// Find first canvas in mixed array
const firstCanvas = items.find(isCanvas);
// firstCanvas is IIIFCanvas | undefined

// Check if any canvases exist
const hasCanvases = items.some(isCanvas);
// hasCanvases is boolean

// Find index of first manifest
const manifestIndex = items.findIndex(isManifest);</code>
    </pattern>
  </rule>

  <rule id="type-guard-10">
    <title>Combining Type Guards with getIIIFValue</title>
    <description>Common pattern: check type, then access localized properties.</description>
    <pattern>
      <code>import { isCanvas, getIIIFValue } from '../types';

const processItem = (item: IIIFItem) => {
  const label = getIIIFValue(item.label, 'en');
  
  if (isCanvas(item)) {
    // Now we have both the label and canvas-specific properties
    return {
      label,
      width: item.width,
      height: item.height
    };
  }
  
  return { label };
};</code>
    </pattern>
  </rule>
</custom_rules>
