<?xml version="1.0" encoding="UTF-8"?>
<tool>
  <name>Performance Optimization Patterns</name>
  <description>Performance optimization rules for React/TypeScript codebase - memoization, callback stability, and render optimization</description>
  
  <rule id="PERF-001" severity="error">
    <name>Inline Arrow Functions in JSX</name>
    <description>Inline arrow functions in JSX create new function references on every render, breaking React.memo and causing unnecessary re-renders</description>
    <patterns>
      <pattern>on(Click|Change|Select|Toggle|Focus|Blur|Submit)=\{\s*\([^)]*\)\s*=></pattern>
      <pattern>on(Scroll|Resize|KeyDown|KeyUp)=\{\s*\([^)]*\)\s*=></pattern>
    </patterns>
    <message>Inline arrow function detected. Extract to useCallback for stable reference.</message>
    <example>
      <before><button onClick={() => setCount(c => c + 1)}>Click</button></before>
      <after>
const handleClick = useCallback(() => setCount(c => c + 1), [setCount]);
<button onClick={handleClick}>Click</button>
      </after>
    </example>
    <quick_fix>
      <step>1. Extract inline function to const with useCallback</step>
      <step>2. Add proper dependency array</step>
      <step>3. Replace inline with stable reference</step>
    </quick_fix>
  </rule>
  
  <rule id="PERF-002" severity="error">
    <name>Missing useMemo on Expensive Operations</name>
    <description>Array operations like filter, sort, map without useMemo recalculate on every render, even when data hasn't changed</description>
    <patterns>
      <pattern>const \w+ = \w+\.(filter|map|sort|reduce)\([^)]+\)\.(filter|map|sort|reduce)?</pattern>
    </patterns>
    <message>Expensive array operation without useMemo. Wrap in useMemo with proper dependencies.</message>
    <example>
      <before>const filtered = items.filter(i => i.active).sort((a, b) => a.name.localeCompare(b.name));</before>
      <after>
const filtered = useMemo(() => 
  items.filter(i => i.active).sort((a, b) => a.name.localeCompare(b.name)),
  [items]
);
      </after>
    </example>
  </rule>
  
  <rule id="PERF-003" severity="warning">
    <name>Inline Object/Array Literals in JSX</name>
    <description>Inline objects and arrays in JSX create new references each render, causing child components to re-render unnecessarily</description>
    <patterns>
      <pattern>style=\{\{[^}]+\}\}</pattern>
      <pattern>className=\{`[^`]+\${[^}]+}[^`]*`\}</pattern>
    </patterns>
    <message>Inline object literal creates new reference each render. Extract to useMemo or use constant.</message>
    <example>
      <before><div style={{ color: 'red', padding: 10 }}></before>
      <after>
const staticStyle = useMemo(() => ({ color: 'red', padding: 10 }), []);
<div style={staticStyle}>
      </after>
    </example>
  </rule>
  
  <rule id="PERF-004" severity="warning">
    <name>Undebounced Input Handlers</name>
    <description>Input handlers that update state on every keystroke can cause performance issues with rapid typing</description>
    <patterns>
      <pattern>onChange=\{e\s*=>\s*set\w+\(e\.target\.value\)\}</pattern>
      <pattern>onInput=\{e\s*=>\s*set\w+\(e\.target\.value\)\}</pattern>
    </patterns>
    <message>Rapid state updates from input. Consider debouncing with useDebouncedCallback.</message>
    <example>
      <before><input onChange={e => setQuery(e.target.value)} /></before>
      <after>
const debouncedSetQuery = useDebouncedCallback(setQuery, 150);
<input onChange={e => debouncedSetQuery(e.target.value)} />
      </after>
    </example>
  </rule>
  
  <rule id="PERF-005" severity="info">
    <name>Component Missing React.memo</name>
    <description>Simple functional components that receive stable props can benefit from React.memo to prevent unnecessary re-renders</description>
    <patterns>
      <pattern>export const (\w+): React\.FC</pattern>
      <pattern>export const (\w+) = \([^)]*\): JSX\.Element</pattern>
    </patterns>
    <message>Consider wrapping component with React.memo if props are stable.</message>
    <example>
      <before>export const MyComponent: React.FC<Props> = ({ name }) => <div>{name}</div>;</before>
      <after>export const MyComponent: React.FC<Props> = React.memo(({ name }) => <div>{name}</div>);</after>
    </example>
  </rule>
  
  <rule id="PERF-006" severity="error">
    <name>Context Provider Without Memoization</name>
    <description>Context providers with inline object values cause all consumers to re-render on every provider update</description>
    <patterns>
      <pattern><\w+Context\.Provider value=\{\{[^}]+\}\}></pattern>
    </patterns>
    <message>Context provider value creates new object each render. Memoize with useMemo.</message>
    <example>
      <before><Context.Provider value={{ state, setState }}></before>
      <after>
const contextValue = useMemo(() => ({ state, setState }), [state, setState]);
<Context.Provider value={contextValue}>
      </after>
    </example>
  </rule>
  
  <rule id="PERF-007" severity="warning">
    <name>Images Without Lazy Loading</name>
    <description>Images below the fold should use lazy loading to improve initial page load time</description>
    <patterns>
      <pattern><img[^>]+src=[^>]*></pattern>
    </patterns>
    <message>Add loading="lazy" attribute for images below the fold.</message>
    <example>
      <before><img src={url} alt="..." /></before>
      <after><img src={url} alt="..." loading="lazy" /></after>
    </example>
  </rule>
  
  <rule id="PERF-008" severity="info">
    <name>Large Components - Code Splitting Candidate</name>
    <description>Components over 500 lines may benefit from code splitting with React.lazy</description>
    <file_thresholds>
      <threshold lines="1000" severity="warning">Large component - consider splitting</threshold>
      <threshold lines="500" severity="info">Medium component - evaluate for lazy loading</threshold>
    </file_thresholds>
    <message>Large component file. Consider code splitting with React.lazy for modal/tool components.</message>
    <example>
      <before>import { HeavyModal } from './HeavyModal';</before>
      <after>
const HeavyModal = React.lazy(() => import('./HeavyModal'));
<Suspense fallback={<Spinner />}><HeavyModal /></Suspense>
      </after>
    </example>
  </rule>
  
  <rule id="PERF-009" severity="info">
    <name>Missing useCallback on Event Handlers</name>
    <description>Event handlers passed to child components should use useCallback for stable references</description>
    <patterns>
      <pattern>const handle\w+ = \(</pattern>
    </patterns>
    <exclusions>
      <pattern>const handle\w+ = useCallback</pattern>
    </exclusions>
    <message>Event handler function. Consider useCallback if passed to memoized children.</message>
  </rule>
  
  <rule id="PERF-010" severity="warning">
    <name>Long Lists Without Virtualization</name>
    <description>Lists with many items should use virtualization to render only visible items</description>
    <patterns>
      <pattern>\{.*\.map\(.*=>.*\{.*key=</pattern>
    </patterns>
    <message>Consider virtualization for long lists (useVirtualization hook available).</message>
    <example>
      <before>{items.map(item => <Row key={item.id} {...item} />)}</before>
      <after>
const { visibleRange } = useVirtualization({ totalItems: items.length, itemHeight: 40 });
{items.slice(visibleRange.start, visibleRange.end).map(item => <Row key={item.id} {...item} />)}
      </after>
    </example>
  </rule>
</tool>
