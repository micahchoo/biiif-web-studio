<?xml version="1.0" encoding="UTF-8"?>
<custom_rules>
  <rule id="hooks-1">
    <title>Use useIIIFTraversal for Tree Operations</title>
    <description>Always use useIIIFTraversal for any tree traversal operations on IIIF resources. It provides memoized O(1) lookups.</description>
    <pattern>
      <code>import { useIIIFTraversal } from '../hooks';

const { 
  findNode,           // O(1) lookup by ID
  findAllByType,      // Get all items of a type
  flattenItems,       // Get flat array of all items
  getChildren,        // Get direct children
  getParent,          // Get parent node
  getAllCanvases,     // Convenience for Canvas[]
  getAllManifests,    // Convenience for Manifest[]
  hasNode,            // Check existence
  getPath             // Get path from root
} = useIIIFTraversal(rootItem);</code>
    </pattern>
    <note>Hook rebuilds lookup maps only when root changes - very efficient for large trees</note>
  </rule>

  <rule id="hooks-2">
    <title>Custom Hook Pattern</title>
    <description>Follow the established custom hook pattern with proper cleanup and TypeScript types.</description>
    <pattern>
      <code>import { useState, useEffect, useCallback } from 'react';

export interface UseMyHookOptions {
  enabled?: boolean;
}

export interface UseMyHookReturn {
  data: SomeType | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useMyHook(
  id: string, 
  options: UseMyHookOptions = {}
): UseMyHookReturn {
  const { enabled = true } = options;
  const [data, setData] = useState<SomeType | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    if (!enabled) return;
    setIsLoading(true);
    try {
      const result = await api.fetch(id);
      setData(result);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err : new Error(String(err)));
    } finally {
      setIsLoading(false);
    }
  }, [id, enabled]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refetch: fetchData };
}</code>
    </pattern>
  </rule>

  <rule id="hooks-3">
    <title>Export Hooks from hooks/index.ts</title>
    <description>Always export new hooks from hooks/index.ts for centralized imports.</description>
    <pattern>
      <code>// hooks/index.ts
export { useMyHook } from './useMyHook';

// Usage elsewhere
import { useMyHook } from '../hooks';</code>
    </pattern>
  </rule>

  <rule id="hooks-4">
    <title>Use useMemo for Expensive Computations</title>
    <description>Memoize expensive computations that depend on IIIF trees or large arrays.</description>
    <pattern>
      <code>const processedItems = useMemo(() => {
  return items.map(item => ({
    ...item,
    displayLabel: new LanguageString(item.label).get('en')
  }));
}, [items]);</code>
    </pattern>
  </rule>

  <rule id="hooks-5">
    <title>Use useCallback for Event Handlers</title>
    <description>Use useCallback for event handlers and callbacks passed to child components.</description>
    <pattern>
      <code>const handleSelect = useCallback((id: string) => {
  setSelectedId(id);
  onSelect?.(id);
}, [onSelect]);</code>
    </pattern>
  </rule>

  <rule id="hooks-6">
    <title>Cleanup in useEffect</title>
    <description>Always provide cleanup functions in useEffect for subscriptions, event listeners, and blob URLs.</description>
    <pattern>
      <code>useEffect(() => {
    const subscription = eventSource.subscribe(handleEvent);
    return () => subscription.unsubscribe();
  }, []);

  useEffect(() => {
    const blobUrl = URL.createObjectURL(file);
    setPreviewUrl(blobUrl);
    return () => URL.revokeObjectURL(blobUrl);
  }, [file]);</code>
    </pattern>
  </rule>
</custom_rules>
