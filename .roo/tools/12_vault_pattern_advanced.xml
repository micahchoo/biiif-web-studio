<?xml version="1.0" encoding="UTF-8"?>
<rooGuidance>
  <section id="vault-advanced">
    <title>Advanced Vault Pattern - Deep Dive</title>
    <description>Comprehensive guide to Field Studio's normalized state management (Vault) including advanced patterns, optimizations, and debugging techniques.</description>

    <subsection id="vault-architecture">
      <title>Vault Architecture</title>

      <pattern id="entity-storage">
        <title>Entity Storage</title>
        <description>The Vault stores IIIF entities in flat Maps for O(1) lookup</description>
        <code language="typescript">
// Vault structure
interface Vault {
  // Flat entity storage
  collections: Map&lt;string, ICollection&gt;
  manifests: Map&lt;string, IManifest&gt;
  canvases: Map&lt;string, ICanvas&gt;
  ranges: Map&lt;string, IRange&gt;
  annotationPages: Map&lt;string, IAnnotationPage&gt;
  annotations: Map&lt;string, IAnnotation&gt;

  // Denormalized indexes for fast traversal
  collectionStructure: Map&lt;collectionId, childIds[]&gt;
  manifestStructure: Map&lt;manifestId, canvasIds[]&gt;
  manifestRanges: Map&lt;manifestId, rangeIds[]&gt;
  annotationStructure: Map&lt;canvasId, annotationPageIds[]&gt;

  // Quick type lookup
  typeIndex: Map&lt;entityId, EntityType&gt;
}
        </code>
      </pattern>

      <pattern id="normalization-process">
        <title>Normalization Process</title>
        <description>How nested IIIF trees become flat normalized entities</description>
        <code language="typescript">
// Before normalization (nested tree):
const tree = {
  id: 'collection-123',
  type: 'Collection',
  label: { en: ['My Archive'] },
  items: [
    {
      id: 'manifest-456',
      type: 'Manifest',
      label: { en: ['Document 1'] },
      items: [
        {
          id: 'canvas-789',
          type: 'Canvas',
          label: { en: ['Page 1'] },
          items: [/* annotations */]
        }
      ]
    }
  ]
}

// After normalization (flat entities):
vault.collections.set('collection-123', {
  id: 'collection-123',
  type: 'Collection',
  label: { en: ['My Archive'] },
  // Relationships are stored separately
})

vault.manifests.set('manifest-456', {
  id: 'manifest-456',
  type: 'Manifest',
  label: { en: ['Document 1'] },
  // Canvas IDs referenced by ID, not full objects
})

vault.canvases.set('canvas-789', {
  id: 'canvas-789',
  type: 'Canvas',
  label: { en: ['Page 1'] },
})

// Structure stored in index
vault.collectionStructure.set('collection-123', ['manifest-456'])
vault.manifestStructure.set('manifest-456', ['canvas-789'])
vault.typeIndex.set('collection-123', 'Collection')
vault.typeIndex.set('manifest-456', 'Manifest')
vault.typeIndex.set('canvas-789', 'Canvas')
        </code>
      </pattern>

      <pattern id="denormalization-reconstruction">
        <title>Denormalization - Reconstructing Trees</title>
        <description>How to reconstruct nested trees from flat entities for export</description>
        <code language="typescript">
// Reconstruct a collection with all descendants
function reconstructTree(entityId: string, vault: Vault): IIIF.Resource {
  const entity = vault.collections.get(entityId)
  if (!entity) throw new Error(`Entity ${entityId} not found`)

  const reconstructed = { ...entity }

  // Add children by looking up in structure indexes
  const childIds = vault.collectionStructure.get(entityId) || []
  reconstructed.items = childIds.map(childId => {
    // Recursively reconstruct each child
    return reconstructChild(childId, vault)
  })

  return reconstructed
}

// For manifests, include canvases
function reconstructManifest(manifestId: string, vault: Vault): IManifest {
  const manifest = vault.manifests.get(manifestId)
  if (!manifest) throw new Error(`Manifest ${manifestId} not found`)

  const canvasIds = vault.manifestStructure.get(manifestId) || []
  return {
    ...manifest,
    items: canvasIds.map(cid => vault.canvases.get(cid)!)
  }
}
        </code>
      </pattern>
    </subsection>

    <subsection id="vault-operations">
      <title>Vault Operations</title>

      <pattern id="immutable-updates">
        <title>Immutable Updates with Immer</title>
        <description>All vault updates use Immer for immutability and performance</description>
        <code language="typescript">
import { produce } from 'immer'

// ✅ CORRECT: Use Immer for immutable updates
const updatedVault = produce(vault, draft => {
  const manifest = draft.manifests.get('manifest-123')
  if (manifest) {
    manifest.label = { en: ['New Label'] }
  }
})

// ❌ WRONG: Direct mutation
vault.manifests.get('manifest-123').label = { en: ['New Label'] }

// Immer benefits:
// - Draft is mutable, final state is immutable
// - Efficient structural sharing (only changed parts copied)
// - Automatic detection of changes
// - No need for manual cloning
        </code>
      </pattern>

      <pattern id="batch-operations">
        <title>Batch Operations</title>
        <description>Efficiently update multiple entities in one action</description>
        <code language="typescript">
// ✅ Use BATCH_UPDATE action for related changes
actions.batchUpdate([
  {
    type: 'UPDATE_LABEL',
    id: 'manifest-1',
    label: { en: ['Updated 1'] }
  },
  {
    type: 'UPDATE_LABEL',
    id: 'manifest-2',
    label: { en: ['Updated 2'] }
  },
  {
    type: 'REORDER_CANVASES',
    manifestId: 'manifest-1',
    canvasIds: ['canvas-3', 'canvas-1', 'canvas-2']
  }
])

// Benefits:
// - Single vault state update (prevents intermediate states)
// - All-or-nothing atomicity
// - Single history entry (easy undo)
// - Subscribers notified once

// ❌ Avoid: Multiple individual actions in loop
for (const id of entityIds) {
  actions.updateLabel(id, newLabel) // Triggers 3 updates!
}
        </code>
      </pattern>

      <pattern id="relationship-consistency">
        <title>Maintaining Relationship Consistency</title>
        <description>How to keep structure indexes in sync with entity changes</description>
        <code language="typescript">
// When adding a canvas to a manifest:
// 1. Add canvas entity
vault.canvases.set(canvasId, canvasEntity)

// 2. Update manifest.items array
const manifest = vault.manifests.get(manifestId)
manifest.items.push(canvasId)

// 3. Update structure index
const canvasIds = vault.manifestStructure.get(manifestId) || []
canvasIds.push(canvasId)
vault.manifestStructure.set(manifestId, canvasIds)

// 4. Update type index
vault.typeIndex.set(canvasId, 'Canvas')

// ✅ Use action system - it handles all steps
actions.addCanvas(manifestId, canvasEntity)

// ❌ Never manually update just one piece
vault.canvases.set(canvasId, canvasEntity)
// Missing: manifest.items, structure index, type index!
        </code>
      </pattern>
    </subsection>

    <subsection id="debugging-patterns">
      <title>Debugging Patterns</title>

      <pattern id="state-inspection">
        <title>State Inspection</title>
        <description>How to safely inspect vault state for debugging</description>
        <code language="typescript">
// In browser console:
import { store } from '@/store' // or your state provider

// View entire vault
console.log(store.getState())

// View specific entity type
console.log(store.getState().manifests)

// Find specific entity
const id = 'canvas-123'
const vault = store.getState()
const entity = (
  vault.canvases.get(id) ||
  vault.manifests.get(id) ||
  vault.collections.get(id)
)
console.log(entity)

// Check relationships
const manifestId = 'manifest-456'
const canvasIds = vault.manifestStructure.get(manifestId)
console.log(`Manifest has ${canvasIds?.length || 0} canvases`)

// Verify consistency
canvasIds?.forEach(cid => {
  if (!vault.canvases.has(cid)) {
    console.error(`⚠️ Broken reference: Canvas ${cid} not found`)
  }
})
        </code>
      </pattern>

      <pattern id="action-tracing">
        <title>Action Tracing</title>
        <description>Track action execution for debugging state changes</description>
        <code language="typescript">
// Subscribe to all actions
import { actions } from '@/services/actions'

actions.subscribe(event => {
  console.log('Action executed:', {
    type: event.type,
    payload: event.payload,
    timestamp: new Date(event.timestamp),
    resultingState: event.resultingState
  })
})

// Or intercept specific action types
const originalUpdateLabel = actions.updateLabel
actions.updateLabel = function(id, label) {
  console.log(`Updating label for ${id}:`, label)
  const result = originalUpdateLabel.call(this, id, label)
  console.log('Result:', result)
  return result
}

// View history
const { undoStack, redoStack } = actions.getHistory()
console.log('Recent actions:', undoStack.slice(-5))
        </code>
      </pattern>

      <pattern id="consistency-validation">
        <title>Consistency Validation</title>
        <description>Automated checks to detect state corruption</description>
        <code language="typescript">
function validateVaultConsistency(vault: Vault): string[] {
  const errors: string[] = []

  // Check 1: All entities exist in typeIndex
  for (const [id, manifest] of vault.manifests) {
    if (!vault.typeIndex.has(id)) {
      errors.push(`Manifest ${id} missing from typeIndex`)
    }
  }

  // Check 2: All typeIndex entries exist
  for (const [id, type] of vault.typeIndex) {
    const typeMap = vault[`${type.toLowerCase()}s` as keyof Vault] as Map&lt;string, any&gt;
    if (!typeMap?.has(id)) {
      errors.push(`typeIndex references non-existent ${type} ${id}`)
    }
  }

  // Check 3: Canvas references are valid
  for (const [manifestId, canvasIds] of vault.manifestStructure) {
    for (const canvasId of canvasIds) {
      if (!vault.canvases.has(canvasId)) {
        errors.push(`Manifest ${manifestId} references missing Canvas ${canvasId}`)
      }
    }
  }

  // Check 4: All canvases are in a manifest
  for (const canvasId of vault.canvases.keys()) {
    let found = false
    for (const [, canvasIds] of vault.manifestStructure) {
      if (canvasIds.includes(canvasId)) {
        found = true
        break
      }
    }
    if (!found) {
      errors.push(`Orphaned Canvas: ${canvasId} not in any manifest`)
    }
  }

  return errors
}

// Run validation
const errors = validateVaultConsistency(vault)
if (errors.length > 0) {
  console.error('Vault consistency issues:', errors)
} else {
  console.log('✓ Vault is consistent')
}
        </code>
      </pattern>
    </subsection>

    <subsection id="performance-considerations">
      <title>Performance Considerations</title>

      <pattern id="lazy-loading">
        <title>Lazy Loading Large Manifests</title>
        <description>Pattern for loading large manifests efficiently</description>
        <code language="typescript">
// For very large manifests (1000+ canvases):

// ✅ Load in chunks
async function loadLargeManifest(manifestId: string, chunkSize = 100) {
  const canvasIds = vault.manifestStructure.get(manifestId) || []

  for (let i = 0; i &lt; canvasIds.length; i += chunkSize) {
    const chunk = canvasIds.slice(i, i + chunkSize)

    // Load chunk
    await loadCanvases(chunk)

    // Yield to render thread
    await new Promise(resolve => requestIdleCallback(resolve))
  }
}

// ✅ Use virtualization for display
import { FixedSizeList } from 'react-window'

function CanvasList({ manifestId }) {
  const canvasIds = vault.manifestStructure.get(manifestId) || []

  return (
    &lt;FixedSizeList
      height={600}
      itemCount={canvasIds.length}
      itemSize={100}
      width="100%"
    &gt;
      {({ index, style }) => (
        &lt;CanvasItem
          key={canvasIds[index]}
          canvasId={canvasIds[index]}
          style={style}
        /&gt;
      )}
    &lt;/FixedSizeList&gt;
  )
}
        </code>
      </pattern>

      <pattern id="selective-memoization">
        <title>Selective Memoization</title>
        <description>Use React.memo and useMemo strategically</description>
        <code language="typescript">
// ✅ Memoize expensive rendering components
import { memo } from 'react'

const CanvasItem = memo(function CanvasItem({ canvasId }: { canvasId: string }) {
  const canvas = useIIIFEntity(canvasId)
  return &lt;div&gt;{canvas?.label}&lt;/div&gt;
}, (prev, next) => {
  // Custom equality: only re-render if canvasId changes
  return prev.canvasId === next.canvasId
})

// ✅ Cache expensive computations
function ManifestView({ manifestId }) {
  const manifest = useIIIFEntity(manifestId)

  const canvases = useMemo(
    () =&gt; vault.manifestStructure.get(manifestId)?.map(id =&gt; vault.canvases.get(id)),
    [manifestId, vault.manifestStructure, vault.canvases]
  )

  return &lt;div&gt;{canvases?.length} canvases&lt;/div&gt;
}

// ❌ Avoid: Memoizing everything
// Excessive memoization creates overhead without benefit
const TinyComponent = memo(function({ label }) {
  return &lt;span&gt;{label}&lt;/span&gt;  // Simple render, no memoization benefit
})
        </code>
      </pattern>
    </subsection>

    <subsection id="testing-patterns">
      <title>Testing Vault Operations</title>

      <pattern id="vault-test-setup">
        <title>Vault Test Setup</title>
        <description>How to initialize vault state for testing</description>
        <code language="typescript">
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { createVault } from '@/services/vault'
import { actions } from '@/services/actions'

describe('Vault Operations', () => {
  let vault: Vault

  beforeEach(() => {
    // Create fresh vault for each test
    vault = createVault()
  })

  it('should add canvas to manifest', () => {
    // Arrange: Setup initial entities
    const collectionId = 'collection-123'
    const manifestId = 'manifest-456'
    const canvasId = 'canvas-789'

    actions.addCollection(collectionId, { label: { en: ['Test'] } })
    actions.addManifest(collectionId, manifestId, { label: { en: ['Doc'] } })

    // Act: Perform operation
    actions.addCanvas(manifestId, {
      id: canvasId,
      type: 'Canvas',
      label: { en: ['Page 1'] }
    })

    // Assert: Verify state
    expect(vault.canvases.has(canvasId)).toBe(true)

    const canvasIds = vault.manifestStructure.get(manifestId)
    expect(canvasIds).toContain(canvasId)
  })

  it('should maintain consistency after batch update', () => {
    // Setup and act...
    actions.batchUpdate([/* ... */])

    // Assert: Run validation
    const errors = validateVaultConsistency(vault)
    expect(errors).toEqual([])
  })
})
        </code>
      </pattern>
    </subsection>

    <subsection id="anti-patterns">
      <title>Anti-Patterns to Avoid</title>

      <pattern id="avoid-direct-mutation">
        <title>❌ Direct Vault Mutation</title>
        <description>Never modify vault state directly outside the action system</description>
        <code language="typescript">
// ❌ WRONG: Direct mutation
const manifest = vault.manifests.get('manifest-123')
manifest.label = { en: ['New Label'] }  // Breaks reactivity!

// ✅ CORRECT: Use action system
actions.updateLabel('manifest-123', { en: ['New Label'] })

// Why this matters:
// - Direct mutation bypasses validation
// - Subscribers not notified
// - Undo/redo broken
// - Consistency checks fail
// - Component re-renders don't trigger
        </code>
      </pattern>

      <pattern id="avoid-stale-references">
        <title>❌ Stale Entity References</title>
        <description>Don't store direct references to vault entities</description>
        <code language="typescript">
// ❌ WRONG: Storing stale reference
let cachedManifest = vault.manifests.get('manifest-123')
// Later...
console.log(cachedManifest.label)  // May be stale!

// ✅ CORRECT: Always look up fresh
const manifest = vault.manifests.get('manifest-123')
console.log(manifest.label)

// ✅ BETTER: In React components, use hooks
function MyComponent({ manifestId }) {
  const manifest = useIIIFEntity(manifestId)  // Always fresh
  return &lt;div&gt;{manifest.label}&lt;/div&gt;
}
        </code>
      </pattern>

      <pattern id="avoid-deep-cloning">
        <title>❌ Deep Cloning</title>
        <description>Don't manually deep clone entities (use Immer)</description>
        <code language="typescript">
// ❌ WRONG: Deep clone
const clone = JSON.parse(JSON.stringify(vault.manifests.get('id')))
clone.label = { en: ['New'] }
vault.manifests.set('id', clone)  // Not a proper update!

// ✅ CORRECT: Use action system
actions.updateLabel('id', { en: ['New'] })

// Immer handles cloning efficiently:
// - Only changed paths are cloned
// - Unchanged paths share references
// - Automatic detection of what changed
        </code>
      </pattern>
    </subsection>

  </section>
</rooGuidance>
