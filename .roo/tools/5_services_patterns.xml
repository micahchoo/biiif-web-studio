<?xml version="1.0" encoding="UTF-8"?>
<custom_rules>
  <rule id="services-1">
    <title>Service Function Pattern</title>
    <description>Follow the established service pattern for IIIF operations.</description>
    <pattern>
      <code>// services/myService.ts
import { IIIFItem, IIIFManifest } from '../types';

export interface MyServiceOptions {
  baseUrl: string;
  includeMetadata?: boolean;
}

export interface MyServiceResult {
  item: IIIFItem;
  warnings: string[];
}

export async function myServiceOperation(
  input: IIIFItem,
  options: MyServiceOptions
): Promise<MyServiceResult> {
  const { baseUrl, includeMetadata = true } = options;
  
  // Implementation
  
  return {
    item: processedItem,
    warnings: []
  };
}</code>
    </pattern>
  </rule>

  <rule id="services-2">
    <title>Export Services from services/index.ts</title>
    <description>Always export new services from services/index.ts for centralized imports.</description>
    <pattern>
      <code>// services/index.ts
export { myServiceOperation } from './myService';

// Usage elsewhere
import { myServiceOperation } from '../services';</code>
    </pattern>
  </rule>

  <rule id="services-3">
    <title>Use iiifBuilder for Manifest Construction</title>
    <description>Use services/iiifBuilder.ts for creating and modifying IIIF manifests.</description>
    <pattern>
      <code>import { iiifBuilder } from '../services';

const manifest = iiifBuilder.createManifest({
  id: manifestId,
  label: new LanguageString({ en: ['My Manifest'] }),
  items: canvases
});</code>
    </pattern>
  </rule>

  <rule id="services-4">
    <title>Use vault for Storage Operations</title>
    <description>Use services/vault.ts for all IndexedDB storage operations.</description>
    <pattern>
      <code>import { vault } from '../services';

// Store
await vault.put('manifests', manifest.id, manifest);

// Retrieve
const manifest = await vault.get<IIIFManifest>('manifests', id);

// Query
const allManifests = await vault.getAll<IIIFManifest>('manifests');</code>
    </pattern>
  </rule>

  <rule id="services-5">
    <title>Use selectors for State Access</title>
    <description>Use services/selectors.ts for memoized state selection logic.</description>
    <pattern>
      <code>import { selectManifestsByCollection, selectCanvasCount } from '../services/selectors';

const manifests = selectManifestsByCollection(state, collectionId);
const count = selectCanvasCount(state, manifestId);</code>
    </pattern>
  </rule>

  <rule id="services-6">
    <title>Error Handling in Services</title>
    <description>Always wrap service operations in try-catch and return structured error responses.</description>
    <pattern>
      <code>export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  warnings?: string[];
}

export async function safeOperation(): Promise<ServiceResult<IIIFItem>> {
  try {
    const result = await riskyCall();
    return { success: true, data: result };
  } catch (err) {
    return { 
      success: false, 
      error: err instanceof Error ? err.message : 'Unknown error' 
    };
  }
}</code>
    </pattern>
  </rule>

  <rule id="services-7">
    <title>Use validationHealer for IIIF Validation</title>
    <description>Use services/validationHealer.ts for validating and auto-fixing IIIF resources.</description>
    <pattern>
      <code>import { validateAndHeal } from '../services/validationHealer';

const { healed, issues, fixed } = validateAndHeal(manifest);
// issues: array of validation problems
// fixed: boolean indicating if changes were made</code>
    </pattern>
  </rule>
</custom_rules>
