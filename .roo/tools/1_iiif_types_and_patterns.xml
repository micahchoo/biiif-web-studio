<?xml version="1.0" encoding="UTF-8"?>
<custom_rules>
  <rule id="iiif-types-1">
    <title>Use Type Guards for IIIF Resource Narrowing</title>
    <description>Always use the type guards from types.ts when narrowing IIIF item types instead of manual type checks.</description>
    <pattern>
      <bad>if (item.type === 'Canvas') { ... }</bad>
      <good>if (isCanvas(item)) { ... }</good>
    </pattern>
    <available_guards>
      <guard>isCanvas(item)</guard>
      <guard>isManifest(item)</guard>
      <guard>isCollection(item)</guard>
      <guard>isRange(item)</guard>
      <guard>isAnnotation(item)</guard>
      <guard>isAnnotationPage(item)</guard>
      <guard>isTextualBody(body)</guard>
      <guard>isExternalWebResource(body)</guard>
      <guard>isSpecificResource(target)</guard>
    </available_guards>
    <import>import { isCanvas, isManifest, isCollection } from '../types';</import>
  </rule>

  <rule id="iiif-types-2">
    <title>Use getIIIFValue for Language Map Access</title>
    <description>Use the getIIIFValue helper for simple language map access. Use LanguageString class for complex operations (chaining, setting values).</description>
    <pattern>
      <bad>const title = item.label?.en?.[0] || '';</bad>
      <good>const title = getIIIFValue(item.label, 'en');</good>
    </pattern>
    <pattern>
      <bad>const label = map?.['none']?.[0] || map?.['en']?.[0] || '';</bad>
      <good>const label = getIIIFValue(map, 'none') || getIIIFValue(map, 'en');</good>
    </pattern>
    <import>import { getIIIFValue } from '../types';</import>
    <note>For complex language map operations (setting values, chaining), use LanguageString class instead</note>
  </rule>

  <rule id="iiif-types-2a">
    <title>Use LanguageString for Complex Language Operations</title>
    <description>Use the LanguageString class for complex language map operations like setting values, chaining, or checking emptiness.</description>
    <pattern>
      <code>const langStr = new LanguageString(item.label);
const title = langStr.get('en');
const updated = langStr.set('en', 'New Title');
if (langStr.isEmpty()) { ... }</code>
    </pattern>
    <methods>
      <method>get(locale?: string): string - Get first value with fallback chain</method>
      <method>set(locale, value): LanguageString - Immutable set (returns new instance)</method>
      <method>isEmpty(): boolean - Check if any locale has content</method>
      <method>toJSON(): LanguageMap - Export as IIIF-compliant language map</method>
    </methods>
    <import>import { LanguageString } from '../types';</import>
  </rule>

  <rule id="iiif-types-3">
    <title>IIIF Item Type Hierarchy</title>
    <description>Understand the IIIF Presentation API 3.0 resource hierarchy used in this codebase.</description>
    <hierarchy>
      <level>Collection → Manifest[] | Collection[]</level>
      <level>Manifest → Canvas[]</level>
      <level>Canvas → AnnotationPage[] (items)</level>
      <level>AnnotationPage → Annotation[]</level>
      <level>Annotation → body (TextualBody | ExternalWebResource)</level>
    </hierarchy>
  </rule>

  <rule id="iiif-types-4">
    <title>Use IIIFItem Interface as Base Type</title>
    <description>When accepting any IIIF resource as a parameter, use IIIFItem as the base type and narrow with type guards.</description>
    <pattern>
      <code>function processItem(item: IIIFItem) {
  if (isCanvas(item)) {
    // TypeScript knows item is IIIFCanvas here
    return item.width * item.height;
  }
}</code>
    </pattern>
  </rule>

  <rule id="iiif-types-5">
    <title>Use IIIF_CONFIG for ID Generation</title>
    <description>Always use IIIF_CONFIG.ID_PATTERNS for generating IIIF resource IDs to ensure consistency.</description>
    <pattern>
      <bad>const id = `${baseUrl}/manifest/${uuid}`;</bad>
      <good>const id = IIIF_CONFIG.ID_PATTERNS.MANIFEST(baseUrl, uuid);</good>
    </pattern>
    <import>import { IIIF_CONFIG } from '../constants';</import>
  </rule>
</custom_rules>
