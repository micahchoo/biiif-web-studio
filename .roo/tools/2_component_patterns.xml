<?xml version="1.0" encoding="UTF-8"?>
<custom_rules>
  <rule id="component-1">
    <title>Use Icon Component for Material Icons</title>
    <description>Always use the Icon component for Material Icons instead of inline span elements.</description>
    <pattern>
      <bad><span className="material-icons">folder</span></bad>
      <good><Icon name="folder" className="text-amber-600" /></good>
    </pattern>
    <props>
      <prop>name: string - Material icon name</prop>
      <prop>className?: string - Additional Tailwind classes</prop>
      <prop>onClick?: () => void - Click handler</prop>
      <prop>title?: string - Native tooltip text</prop>
    </props>
    <import>import { Icon } from './Icon';</import>
  </rule>

  <rule id="component-2">
    <title>Use RESOURCE_TYPE_CONFIG for Type Styling</title>
    <description>When displaying IIIF resource types, use RESOURCE_TYPE_CONFIG for consistent icons and colors.</description>
    <pattern>
      <code>import { RESOURCE_TYPE_CONFIG } from '../constants';

const config = RESOURCE_TYPE_CONFIG[item.type] || RESOURCE_TYPE_CONFIG['Content'];
return (
  <div className={`${config.bgClass} ${config.colorClass}`}>
    <Icon name={config.icon} />
    <span>{config.label}</span>
  </div>
);</code>
    </pattern>
    <colors>
      <type name="Collection">amber-600 / amber-100 / amber-200</type>
      <type name="Manifest">emerald-600 / emerald-100 / emerald-200</type>
      <type name="Canvas">blue-500 / blue-100 / blue-200</type>
      <type name="Range">indigo-500 / indigo-100 / indigo-200</type>
      <type name="AnnotationPage">purple-500 / purple-100 / purple-200</type>
      <type name="Annotation">teal-500 / teal-100 / teal-200</type>
    </colors>
  </rule>

  <rule id="component-3">
    <title>Functional Component Pattern with TypeScript</title>
    <description>Use the standard functional component pattern with explicit React.FC typing.</description>
    <pattern>
      <code>interface MyComponentProps {
  item: IIIFItem;
  onSelect?: (id: string) => void;
  className?: string;
}

export const MyComponent: React.FC<MyComponentProps> = ({ 
  item, 
  onSelect,
  className = "" 
}) => {
  // Component logic
  return (
    <div className={`... ${className}`}>
      {/* JSX */}
    </div>
  );
};</code>
    </pattern>
  </rule>

  <rule id="component-4">
    <title>Use EmptyState Component for Empty Views</title>
    <description>Always use the EmptyState component when displaying empty/no-data states.</description>
    <pattern>
      <code>import { EmptyState } from './EmptyState';

<EmptyState 
  icon="folder_open"
  title="No items found"
  message="Upload files to get started"
  action={{
    label: "Upload",
    onClick: handleUpload
  }}
/></code>
    </pattern>
  </rule>

  <rule id="component-5">
    <title>Tailwind CSS Conventions</title>
    <description>Follow established Tailwind patterns in this codebase.</description>
    <conventions>
      <item>Use single quotes in className strings</item>
      <item>Order: layout (flex, grid) → spacing (p-, m-) → sizing (w-, h-) → colors (bg-, text-) → effects</item>
      <item>Use template literals for conditional classes: className={`base ${condition ? 'active' : ''}`}</item>
      <item>Prefer Tailwind utilities over arbitrary values</item>
      <item>Use the designSystem.ts colors when available</item>
    </conventions>
  </rule>

  <rule id="component-6">
    <title>Toast Notifications via useToast Hook</title>
    <description>Use the useToast hook for all user notifications instead of alert() or console.</description>
    <pattern>
      <code>import { useToast } from '../hooks';

const { showToast } = useToast();

// Usage
showToast('Item saved successfully', 'success');
showToast('Failed to load data', 'error');
showToast('Processing...', 'info');</code>
    </pattern>
  </rule>
</custom_rules>
