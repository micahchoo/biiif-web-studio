<?xml version="1.0" encoding="UTF-8"?>
<rooGuidance>
  <section id="web-workers-async">
    <title>Web Workers and Async Patterns</title>
    <description>Comprehensive guide to using Web Workers for background processing and managing complex asynchronous operations in Field Studio.</description>

    <subsection id="web-worker-basics">
      <title>Web Worker Basics</title>

      <pattern id="worker-creation">
        <title>Creating Web Workers</title>
        <description>Proper pattern for creating and communicating with Web Workers</description>
        <code language="typescript">
// 1. Create worker file: src/workers/example.worker.ts
export {}
declare const self: Worker

self.onmessage = (event: MessageEvent&lt;{
  type: 'PROCESS' | 'CANCEL'
  data?: any
}&gt;) =&gt; {
  const { type, data } = event.data

  if (type === 'PROCESS') {
    // Do heavy computation in background
    const result = expensiveOperation(data)

    // Send result back
    self.postMessage({
      type: 'COMPLETE',
      result
    })
  }

  if (type === 'CANCEL') {
    // Handle cancellation
    self.postMessage({
      type: 'CANCELLED'
    })
  }
}

// 2. Use worker in component: src/components/MyComponent.tsx
import { useEffect, useRef } from 'react'

export function MyComponent() {
  const workerRef = useRef&lt;Worker | null&gt;(null)

  useEffect(() => {
    // Create worker with proper module type
    workerRef.current = new Worker(
      new URL('../workers/example.worker.ts', import.meta.url),
      { type: 'module' }
    )

    // Setup message handler
    workerRef.current.onmessage = (event) =&gt; {
      const { type, result } = event.data

      if (type === 'COMPLETE') {
        console.log('Worker finished:', result)
        // Update UI with result
      }
    }

    // Setup error handler
    workerRef.current.onerror = (error) =&gt; {
      console.error('Worker error:', error)
    }

    // Cleanup on unmount
    return () =&gt; {
      workerRef.current?.terminate()
    }
  }, [])

  const handleStart = () =&gt; {
    // Send message to worker
    workerRef.current?.postMessage({
      type: 'PROCESS',
      data: { /* ... */ }
    })
  }

  return &lt;button onClick={handleStart}&gt;Start Processing&lt;/button&gt;
}
        </code>
      </pattern>

      <pattern id="worker-with-progress">
        <title>Worker with Progress Reporting</title>
        <description>Long-running workers that report progress back to main thread</description>
        <code language="typescript">
// Worker: src/workers/tileGeneration.worker.ts
self.onmessage = async (event: MessageEvent&lt;{
  assetId: string
  imageData: ArrayBuffer
  maxLevel: number
}&gt;) =&gt; {
  const { assetId, imageData, maxLevel } = event.data
  const totalTiles = calculateTotalTiles(maxLevel)

  try {
    for (let level = 0; level &lt;= maxLevel; level++) {
      const tiles = generateTilesForLevel(imageData, level)

      // Report progress
      self.postMessage({
        type: 'PROGRESS',
        processed: calculateProcessed(level),
        total: totalTiles,
        currentLevel: level
      })

      // Yield to prevent blocking
      await new Promise(resolve =&gt; setTimeout(resolve, 0))
    }

    self.postMessage({
      type: 'COMPLETE',
      assetId,
      tileCount: totalTiles
    })
  } catch (error) {
    self.postMessage({
      type: 'ERROR',
      message: error.message
    })
  }
}

// Main thread: src/hooks/useTileGeneration.ts
import { useState, useRef, useCallback } from 'react'

export function useTileGeneration() {
  const [progress, setProgress] = useState({ processed: 0, total: 0 })
  const [status, setStatus] = useState&lt;'idle' | 'generating' | 'complete' | 'error'&gt;('idle')
  const workerRef = useRef&lt;Worker | null&gt;(null)

  const generate = useCallback(async (assetId: string, imageData: ArrayBuffer) =&gt; {
    return new Promise((resolve, reject) =&gt; {
      if (!workerRef.current) {
        workerRef.current = new Worker(
          new URL('../workers/tileGeneration.worker.ts', import.meta.url),
          { type: 'module' }
        )
      }

      setStatus('generating')

      workerRef.current.onmessage = (event) =&gt; {
        const { type, processed, total, tileCount, message } = event.data

        if (type === 'PROGRESS') {
          setProgress({ processed, total })
        } else if (type === 'COMPLETE') {
          setStatus('complete')
          resolve({ assetId, tileCount })
        } else if (type === 'ERROR') {
          setStatus('error')
          reject(new Error(message))
        }
      }

      workerRef.current.postMessage({
        assetId,
        imageData,
        maxLevel: 10  // Adjust based on image size
      })
    })
  }, [])

  const cancel = useCallback(() =&gt; {
    workerRef.current?.postMessage({ type: 'CANCEL' })
    setStatus('idle')
  }, [])

  return { generate, cancel, progress, status }
}
        </code>
      </pattern>
    </subsection>

    <subsection id="worker-patterns">
      <title>Common Worker Patterns</title>

      <pattern id="search-indexing-worker">
        <title>Search Indexing Worker</title>
        <description>Background indexing for search functionality</description>
        <code language="typescript">
// src/workers/searchIndexer.ts
import FlexSearch from 'flexsearch'

let index: FlexSearch.Document | null = null

self.onmessage = async (event: MessageEvent&lt;{
  type: 'INIT' | 'INDEX' | 'SEARCH' | 'CLEAR'
  data?: any
}&gt;) =&gt; {
  const { type, data } = event.data

  switch (type) {
    case 'INIT':
      // Initialize search index
      index = new FlexSearch.Document({
        document: {
          id: 'id',
          index: ['label', 'description']
        },
        tokenize: 'full',
        cache: true
      })
      self.postMessage({ type: 'READY' })
      break

    case 'INDEX':
      // Add documents to index (manifests, canvases, etc.)
      if (index) {
        data.documents.forEach(doc =&gt; {
          index!.add(doc)
        })

        self.postMessage({
          type: 'INDEXED',
          count: data.documents.length
        })
      }
      break

    case 'SEARCH':
      // Search index
      if (index) {
        const results = index.search(data.query, {
          limit: data.limit || 50,
          suggest: true
        })

        self.postMessage({
          type: 'RESULTS',
          results,
          query: data.query
        })
      }
      break

    case 'CLEAR':
      index = null
      self.postMessage({ type: 'CLEARED' })
      break
  }
}

// src/services/searchService.ts
export class SearchService {
  private worker: Worker

  constructor() {
    this.worker = new Worker(
      new URL('../workers/searchIndexer.ts', import.meta.url),
      { type: 'module' }
    )

    // Initialize worker
    this.worker.postMessage({ type: 'INIT' })
  }

  async indexDocuments(documents: Array&lt;{ id: string; label?: string; description?: string }&gt;) {
    return new Promise((resolve) =&gt; {
      const handler = (event: MessageEvent) =&gt; {
        if (event.data.type === 'INDEXED') {
          this.worker.removeEventListener('message', handler)
          resolve(event.data.count)
        }
      }

      this.worker.addEventListener('message', handler)
      this.worker.postMessage({
        type: 'INDEX',
        data: { documents }
      })
    })
  }

  search(query: string, limit?: number): Promise&lt;any[]&gt; {
    return new Promise((resolve) =&gt; {
      const handler = (event: MessageEvent) =&gt; {
        if (event.data.type === 'RESULTS' &amp;&amp; event.data.query === query) {
          this.worker.removeEventListener('message', handler)
          resolve(event.data.results)
        }
      }

      this.worker.addEventListener('message', handler)
      this.worker.postMessage({
        type: 'SEARCH',
        data: { query, limit }
      })
    })
  }

  destroy() {
    this.worker.terminate()
  }
}
        </code>
      </pattern>

      <pattern id="image-processing-worker">
        <title>Image Processing Worker</title>
        <description>Heavy image processing in background thread</description>
        <code language="typescript">
// src/workers/imageProcessing.worker.ts
self.onmessage = async (event: MessageEvent&lt;{
  type: 'RESIZE' | 'CROP' | 'ROTATE'
  imageData: ImageData
  options: any
}&gt;) =&gt; {
  const { type, imageData, options } = event.data

  try {
    let result: ImageData | Uint8ClampedArray

    // Use OffscreenCanvas for image operations
    const canvas = new OffscreenCanvas(imageData.width, imageData.height)
    const ctx = canvas.getContext('2d')!

    ctx.putImageData(imageData, 0, 0)

    switch (type) {
      case 'RESIZE':
        const newCanvas = new OffscreenCanvas(options.width, options.height)
        const newCtx = newCanvas.getContext('2d')!
        newCtx.drawImage(canvas as any, 0, 0, options.width, options.height)
        result = newCtx.getImageData(0, 0, options.width, options.height)
        break

      case 'CROP':
        result = ctx.getImageData(
          options.x, options.y,
          options.width, options.height
        )
        break

      case 'ROTATE':
        // Rotate by angle (degrees)
        const angle = (options.angle * Math.PI) / 180
        // ... rotation logic
        result = ctx.getImageData(0, 0, imageData.width, imageData.height)
        break
    }

    // Transfer result back
    self.postMessage({
      type: 'COMPLETE',
      result
    })
  } catch (error) {
    self.postMessage({
      type: 'ERROR',
      message: error.message
    })
  }
}
        </code>
      </pattern>
    </subsection>

    <subsection id="async-patterns">
      <title>Async Patterns</title>

      <pattern id="abort-controller">
        <title>Using AbortController for Cancellation</title>
        <description>Cancel long-running async operations</description>
        <code language="typescript">
import { useEffect, useRef, useState } from 'react'

export function useAsyncOperation() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState&lt;Error | null&gt;(null)
  const abortControllerRef = useRef&lt;AbortController | null&gt;(null)

  const execute = async (
    operation: (signal: AbortSignal) =&gt; Promise&lt;any&gt;
  ) =&gt; {
    // Cancel previous operation if still running
    abortControllerRef.current?.abort()

    const controller = new AbortController()
    abortControllerRef.current = controller

    setIsLoading(true)
    setError(null)

    try {
      const result = await operation(controller.signal)
      setIsLoading(false)
      return result
    } catch (err) {
      if (err.name !== 'AbortError') {
        setError(err as Error)
      }
      setIsLoading(false)
      throw err
    }
  }

  const cancel = () =&gt; {
    abortControllerRef.current?.abort()
    setIsLoading(false)
  }

  useEffect(() =&gt; {
    // Cleanup on unmount
    return () =&gt; {
      abortControllerRef.current?.abort()
    }
  }, [])

  return { execute, cancel, isLoading, error }
}

// Usage:
function ImportManifestDialog() {
  const { execute, cancel, isLoading } = useAsyncOperation()

  const handleImport = async () =&gt; {
    await execute(async (signal) =&gt; {
      const response = await fetch(url, { signal })
      if (!response.ok) throw new Error('Failed to import')

      const manifest = await response.json()
      return validator.validateTree(manifest)
    })
  }

  return (
    &lt;div&gt;
      &lt;button onClick={handleImport} disabled={isLoading}&gt;
        {isLoading ? 'Importing...' : 'Import'}
      &lt;/button&gt;
      {isLoading &amp;&amp; &lt;button onClick={cancel}&gt;Cancel&lt;/button&gt;}
    &lt;/div&gt;
  )
}
        </code>
      </pattern>

      <pattern id="retry-logic">
        <title>Retry Logic with Exponential Backoff</title>
        <description>Robust retry pattern for network operations</description>
        <code language="typescript">
interface RetryOptions {
  maxAttempts?: number
  initialDelay?: number  // milliseconds
  maxDelay?: number
  backoffMultiplier?: number
  onRetry?: (attempt: number, delay: number) =&gt; void
}

async function withRetry&lt;T&gt;(
  operation: (attempt: number) =&gt; Promise&lt;T&gt;,
  options: RetryOptions = {}
): Promise&lt;T&gt; {
  const {
    maxAttempts = 3,
    initialDelay = 1000,
    maxDelay = 10000,
    backoffMultiplier = 2,
    onRetry
  } = options

  let lastError: Error | null = null

  for (let attempt = 1; attempt &lt;= maxAttempts; attempt++) {
    try {
      return await operation(attempt)
    } catch (error) {
      lastError = error as Error

      if (attempt === maxAttempts) {
        throw error
      }

      // Calculate delay with exponential backoff
      const delay = Math.min(
        initialDelay * Math.pow(backoffMultiplier, attempt - 1),
        maxDelay
      )

      onRetry?.(attempt, delay)

      // Wait before retrying
      await new Promise(resolve =&gt; setTimeout(resolve, delay))
    }
  }

  throw lastError
}

// Usage:
async function importManifest(url: string) {
  return withRetry(
    async (attempt) =&gt; {
      console.log(`Fetching manifest (attempt ${attempt})`)
      const response = await fetch(url)
      if (!response.ok) throw new Error(`HTTP ${response.status}`)
      return response.json()
    },
    {
      maxAttempts: 3,
      initialDelay: 1000,
      onRetry: (attempt, delay) =&gt; {
        console.warn(`Retry ${attempt} after ${delay}ms`)
      }
    }
  )
}
        </code>
      </pattern>

      <pattern id="concurrent-operations">
        <title>Managing Concurrent Operations</title>
        <description>Execute multiple async operations with control</description>
        <code language="typescript">
// Limit concurrent operations to N
class ConcurrencyPool {
  private running = 0
  private queue: Array&lt;() =&gt; Promise&lt;any&gt;&gt; = []

  constructor(private maxConcurrent: number) {}

  async run&lt;T&gt;(operation: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {
    return new Promise((resolve, reject) =&gt; {
      const task = async () =&gt; {
        try {
          const result = await operation()
          resolve(result)
        } catch (error) {
          reject(error)
        } finally {
          this.running--
          this.procesNext()
        }
      }

      if (this.running &lt; this.maxConcurrent) {
        this.running++
        task()
      } else {
        this.queue.push(task)
      }
    })
  }

  private processNext() {
    if (this.running &lt; this.maxConcurrent &amp;&amp; this.queue.length &gt; 0) {
      this.running++
      const task = this.queue.shift()!
      task()
    }
  }
}

// Usage: Process 1000 images with max 4 concurrent downloads
const pool = new ConcurrencyPool(4)

const imageIds = Array.from({ length: 1000 }, (_, i) =&gt; `image-${i}`)

const promises = imageIds.map(id =&gt;
  pool.run(async () =&gt; {
    const blob = await downloadImage(id)
    await storage.saveFile(blob)
  })
)

await Promise.all(promises)
        </code>
      </pattern>

      <pattern id="throttle-debounce">
        <title>Throttle and Debounce Patterns</title>
        <description>Control frequency of async operations</description>
        <code language="typescript">
// Throttle: Execute at most once per interval
function throttle&lt;T extends any[], R&gt;(
  fn: (...args: T) =&gt; Promise&lt;R&gt;,
  delayMs: number
) {
  let lastCall = 0
  let lastResult: R | null = null
  let pending = false

  return async (...args: T): Promise&lt;R&gt; =&gt; {
    const now = Date.now()

    if (now - lastCall &gt;= delayMs &amp;&amp; !pending) {
      lastCall = now
      pending = true

      try {
        lastResult = await fn(...args)
      } finally {
        pending = false
      }
    }

    return lastResult as R
  }
}

// Debounce: Wait for quiet period before executing
function debounce&lt;T extends any[], R&gt;(
  fn: (...args: T) =&gt; Promise&lt;R&gt;,
  delayMs: number
) {
  let timeoutId: NodeJS.Timeout | null = null
  let lastResult: R | null = null

  return async (...args: T): Promise&lt;R&gt; =&gt; {
    if (timeoutId) clearTimeout(timeoutId)

    return new Promise((resolve) =&gt; {
      timeoutId = setTimeout(async () =&gt; {
        lastResult = await fn(...args)
        resolve(lastResult as R)
      }, delayMs)
    })
  }
}

// Usage in React:
import { useCallback, useEffect } from 'react'

function SearchManifests() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])

  // Debounce search: wait 300ms after user stops typing
  const debouncedSearch = useCallback(
    debounce(async (q: string) =&gt; {
      const results = await searchService.search(q)
      setResults(results)
    }, 300),
    []
  )

  useEffect(() =&gt; {
    debouncedSearch(query)
  }, [query, debouncedSearch])

  return (
    &lt;&gt;
      &lt;input
        value={query}
        onChange={(e) =&gt; setQuery(e.target.value)}
        placeholder="Search manifests..."
      /&gt;
      {results.map(r =&gt; &lt;div key={r.id}&gt;{r.label}&lt;/div&gt;)}
    &lt;/&gt;
  )
}
        </code>
      </pattern>
    </subsection>

    <subsection id="error-handling">
      <title>Error Handling in Async Code</title>

      <pattern id="async-error-boundaries">
        <title>Async Error Handling</title>
        <description>Proper error handling for async operations</description>
        <code language="typescript">
// ✅ Correct: Always handle rejections
async function loadManifest(id: string) {
  try {
    const response = await fetch(`/api/manifests/${id}`)

    if (!response.ok) {
      throw new Error(`Failed to load: ${response.status}`)
    }

    const manifest = await response.json()
    return validator.validateTree(manifest)

  } catch (error) {
    if (error instanceof TypeError) {
      // Network error
      console.error('Network error:', error)
    } else if (error instanceof SyntaxError) {
      // JSON parse error
      console.error('Invalid JSON:', error)
    } else {
      // Other errors
      console.error('Error loading manifest:', error)
    }

    throw error  // Re-throw or return null
  }
}

// ❌ Wrong: Unhandled rejection
async function badLoadManifest(id: string) {
  const response = await fetch(`/api/manifests/${id}`)
  const manifest = await response.json()  // May crash!
  return manifest
}

// ✅ Use custom error types
class ManifestError extends Error {
  constructor(
    message: string,
    public readonly cause: Error | null = null,
    public readonly statusCode?: number
  ) {
    super(message)
    this.name = 'ManifestError'
  }
}

async function loadManifestTyped(id: string): Promise&lt;IManifest&gt; {
  try {
    const response = await fetch(`/api/manifests/${id}`)

    if (!response.ok) {
      throw new ManifestError(
        'Failed to load manifest',
        null,
        response.status
      )
    }

    const manifest = await response.json()
    const issues = validator.validateTree(manifest)

    if (issues.some(i =&gt; i.severity === 'error')) {
      throw new ManifestError(
        'Manifest validation failed',
        new Error(issues.map(i =&gt; i.message).join(', '))
      )
    }

    return manifest

  } catch (error) {
    if (error instanceof ManifestError) {
      throw error  // Re-throw known errors
    }

    throw new ManifestError(
      'Unexpected error loading manifest',
      error as Error
    )
  }
}
        </code>
      </pattern>
    </subsection>

  </section>
</rooGuidance>
