<?xml version="1.0" encoding="UTF-8"?>
<custom_rules>
  <rule id="best-1">
    <title>IIIF Best Practices</title>
    <description>Follow IIIF Presentation API 3.0 best practices.</description>
    <practices>
      <item>Collections are "cheap overlays" - they reference resources by ID, not contain them</item>
      <item>Always include @context for exported IIIF resources</item>
      <item>Use language maps for all textual content (label, summary, metadata)</item>
      <item>Generate stable IDs using IIIF_CONFIG.ID_PATTERNS</item>
      <item>Use appropriate behaviors for resource types</item>
      <item>Include thumbnails for better viewer performance</item>
    </practices>
  </rule>

  <rule id="best-1a">
    <title>Type Guard Patterns</title>
    <description>Always use type guards from types.ts instead of direct type string comparisons. This provides TypeScript narrowing and prevents runtime errors.</description>
    <pattern>
      <bad>if (item.type === 'Canvas') { ... }</bad>
      <good>if (isCanvas(item)) { ... }</good>
    </pattern>
    <pattern>
      <bad>const isManifest = item.type === 'Manifest';</bad>
      <good>const isManifestItem = isManifest(item);</good>
    </pattern>
    <pattern>
      <bad>items.filter(i => i.type === 'Canvas')</bad>
      <good>items.filter(isCanvas)</good>
    </pattern>
    <pattern>
      <bad>const icon = p.type === 'Collection' ? 'folder' : p.type === 'Manifest' ? 'book' : 'image';</bad>
      <good>const icon = isCollection(p) ? 'folder' : isManifest(p) ? 'book' : 'image';</good>
    </pattern>
    <available_guards>
      <guard>isCanvas(item)</guard>
      <guard>isManifest(item)</guard>
      <guard>isCollection(item)</guard>
      <guard>isRange(item)</guard>
      <guard>isAnnotation(item)</guard>
      <guard>isAnnotationPage(item)</guard>
    </available_guards>
    <import>import { isCanvas, isManifest, isCollection, isRange } from '../types';</import>
    <note>Type guards provide TypeScript type narrowing - inside an if (isCanvas(item)) block, TypeScript knows item is IIIFCanvas</note>
  </rule>

  <rule id="best-2">
    <title>Type Safety</title>
    <description>Maintain strict TypeScript type safety.</description>
    <practices>
      <item>Use explicit return types on exported functions</item>
      <item>Avoid 'any' - use 'unknown' with type guards when necessary</item>
      <item>Use the IIIFItem union type and narrow with type guards (isCanvas, isManifest, etc.)</item>
      <item>Define interfaces for all component props</item>
      <item>Use getIIIFValue() for simple language map access; LanguageString for complex operations</item>
      <item>Never use direct type string comparisons like item.type === 'Canvas'</item>
    </practices>
  </rule>

  <rule id="best-3">
    <title>Performance</title>
    <description>Follow performance best practices.</description>
    <practices>
      <item>Use useIIIFTraversal instead of manual tree traversal</item>
      <item>Memoize expensive computations with useMemo</item>
      <item>Use useCallback for callbacks passed to children</item>
      <item>Use virtualization for long lists (useVirtualization hook)</item>
      <item>Lazy load heavy components when possible</item>
      <item>Clean up blob URLs and subscriptions in useEffect</item>
    </practices>
  </rule>

  <rule id="best-4">
    <title>Error Handling</title>
    <description>Handle errors gracefully with structured patterns.</description>
    <practices>
      <item>Use ErrorBoundary for component error isolation</item>
      <item>Show user-friendly error messages via useToast</item>
      <item>Log errors to console for debugging</item>
      <item>Return structured error responses from services</item>
      <item>Validate IIIF resources with validationHealer</item>
    </practices>
    <pattern>
      <code>export interface ServiceResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  warnings?: string[];
}

export async function safeOperation(): Promise<ServiceResult<IIIFItem>> {
  try {
    const result = await riskyCall();
    return { success: true, data: result };
  } catch (err) {
    console.error('Operation failed:', err);
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unknown error'
    };
  }
}</code>
    </pattern>
  </rule>

  <rule id="best-5">
    <title>Accessibility</title>
    <description>Follow accessibility best practices.</description>
    <practices>
      <item>Use semantic HTML elements</item>
      <item>Include alt text for images</item>
      <item>Support keyboard navigation</item>
      <item>Use ARIA labels where appropriate</item>
      <item>Ensure sufficient color contrast</item>
    </practices>
  </rule>

  <rule id="best-6">
    <title>Testing Considerations</title>
    <description>Write testable code.</description>
    <practices>
      <item>Keep business logic in services (easier to unit test)</item>
      <item>Keep components focused on presentation</item>
      <item>Export pure functions for testing</item>
      <item>Use dependency injection for testability</item>
    </practices>
  </rule>

  <rule id="best-7">
    <title>Code Comments</title>
    <description>Use comments appropriately.</description>
    <practices>
      <item>Use JSDoc for exported functions and types</item>
      <item>Explain "why" not "what" in inline comments</item>
      <item>Document complex IIIF logic and spec references</item>
      <item>Use TODO comments for known technical debt</item>
    </practices>
  </rule>

  <rule id="best-8">
    <title>Tool Selection Guidelines</title>
    <description>Choose the most efficient tool for each task.</description>
    <guidelines>
      <guideline>Use codebase_search for semantic/meaning-based searches first</guideline>
      <guideline>Use search_files for regex pattern matching only when needed</guideline>
      <guideline>Use read_file to examine file contents before modifications</guideline>
      <guideline>Use apply_diff for surgical edits to existing files</guideline>
      <guideline>Use write_to_file only for new files or complete rewrites</guideline>
      <guideline>Use list_files to explore directory structure</guideline>
      <guideline>Use execute_command for system operations, not file reading</guideline>
    </guidelines>
  </rule>

  <rule id="best-9">
    <title>Common Code Modification Workflow</title>
    <description>Follow the standard workflow for code changes.</description>
    <workflow>
      <step>1. Gather information: Use codebase_search or read_file to understand current state</step>
      <step>2. Plan changes: Identify what needs to be modified</step>
      <step>3. Apply changes: Use apply_diff for targeted edits</step>
      <step>4. Verify: Confirm changes are correct</step>
      <step>5. Complete: Use attempt_completion to summarize</step>
    </workflow>
    <note>Always confirm file contents with read_file if uncertain before using apply_diff</note>
  </rule>

  <rule id="best-10">
    <title>File Access Patterns</title>
    <description>Follow efficient file access patterns.</description>
    <patterns>
      <pattern>Read up to 5 files per read_file call by passing an array</pattern>
      <pattern>Read related files together in a single call</pattern>
      <pattern>Use apply_diff for multiple edits in the same file</pattern>
      <pattern>Wait for user confirmation between file operations</pattern>
      <pattern>Use relative paths from workspace root</pattern>
    </patterns>
  </rule>

  <rule id="best-11">
    <title>Error Recovery</title>
    <description>Handle failures gracefully.</description>
    <strategies>
      <strategy>Validate inputs before operations</strategy>
      <strategy>Use try-catch for async operations</strategy>
      <strategy>Provide meaningful error messages</strategy>
      <strategy>Log errors for debugging</strategy>
      <strategy>Use fallback values when appropriate</strategy>
    </strategies>
  </rule>
</custom_rules>
